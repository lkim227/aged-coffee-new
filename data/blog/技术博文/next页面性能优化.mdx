---
title: next 页面性能优化
date: '2023-12-25'
tags: ['通用','原创']
draft: false
summary: ""
---

<TOCInlineWithSticky toc={props.toc} />

## 添加 dns-prefetch、preconnect meta 标签

```tsx
<Head>
  <link rel="dns-prefetch" href="//example.com" />
  <link rel="preconnect" href="//example.com" />
</Head>
```

## 图片压缩

尽量使用 webp 格式图片和压缩图片

## 图片懒加载

```tsx
<Image loading="lazy" src={renderItem.img} alt="" fill  />
```

## [自部署 next 服务的自定义图片 loader 优化](https://nextjs.org/docs/app/api-reference/components/image#loader)

```tsx
'use client'

import React, { ComponentProps } from 'react';
import Image from 'next/image';

export const CustomLoaderImg = (props: ComponentProps<typeof Image>) => {
  return (
    <Image
      {...props}
      loader={({ src, width, quality }) => {
        // 确认一个可用的图片优化服务之后替换
        return `https://optimize-img.com?url=${src}?w=${width}&q=${quality || 75}`;
      }}
    />
  );
};
```

## 部分逻辑组件和渲染内容独立于服务端渲染

有些组件作为用为用户交互之后才需要展示的内容，例如预留好插槽的 Modal 组件，类似这样的组件没有服务端渲的必要，可以考虑修改他的实现为仅客户端渲染  

另外一种情况是渲染有关于时间的内容的时候，由于服务端和客户端有时候有些微的差异进而会导致水合的错误

具体的实现方法可以通过

1. 使用 next 提供的 dynamic 

```tsx
import dynamic from 'next/dynamic';

//仅在客户端动态导入并渲染 Modal 组件
const DynamicModal = dynamic(
  () => import('../components/Modal'),
  { ssr: false }  // 这将禁用服务器端渲染（SSR）
);

// 仅在客户端动态导入并渲染 Time 相关组件
const DynamicTime = dynamic(
  () => import('../components/Time'),
  { ssr: false }  // 这将禁用服务器端渲染（SSR）
);
```

2. useEffect 中动态引入

```tsx
import React, { useState, useEffect } from 'react';

function YourComponent() {
  const [DynamicComponent, setDynamicComponent] = useState(null);

  useEffect(() => {
    import('../components/Modal').then((Modal) => {
      setDynamicComponent(() => Modal.default); // 注意 Modal.default
    });
  }, []);

  if (!DynamicComponent) return <p>Loading...</p>;

  return <DynamicComponent />;
}
```

3. 首帧之后才实际渲染最终内容

```tsx
import React, { useState, useEffect } from 'react';
import Modal from '../components/Modal';

function YourComponent() {
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    // 在 useEffect 中设置标志表示现在是在客户端了
    setIsClient(true);
  }, []);

  if (!isClient) return <p>Loading...</p>;

  return <Modal />;
}
```

## 打包静态资源上传到 CDN 的插件

```tsx
/* eslint-disable react-func/max-lines-per-function */
/* eslint-disable max-depth */
const request = require('request');

function getCdnUrlPrefix(options) {
  return `${options.packageVersion}/${options?.isEnvProduction ? 'prod' : 'dev'}`;
}

function UploadCDN(options) {
  this.isEnvProduction = options?.isEnvProduction ?? false;
  this.options = options;
}

function upload(options) {
  return new Promise((resolve, reject) => {
    request(options, function (error, response) {
      if (error) reject(error);
      resolve();
    });
  });
}
UploadCDN.prototype.apply = function (compiler) {
  // eslint-disable-next-line react-func/max-lines-per-function
  compiler.hooks.emit.tapAsync('UploadCDN', async (compilation, callback) => {
    // formData list
    let optionsMap = {};
    let commonOptions = {
      method: 'POST',
      url: 'https://your-cdn-serverice/api/v1/files',
      headers: {
        module: this.options.module,
        _dir: '/',
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      formData: {},
    };
    for (let fileName in compilation.assets) {
      if (!fileName.endsWith('map')) {
        const parts = fileName.split('/');
        const filename = parts.pop();
        const _dir = `${getCdnUrlPrefix(this.options)}/_next/${parts.join('/')}`;
        const formData = {
          value: compilation.assets[fileName].source(),
          options: {
            filename,
            contentType: null,
          },
        };
        if (!optionsMap[_dir]) {
          optionsMap[_dir] = {
            ...JSON.parse(JSON.stringify(commonOptions)),
          };
          optionsMap[_dir].headers._dir = _dir;
        }
        optionsMap[_dir].formData[filename] = formData;
      }
    }

    const optionsArr = Object.keys(optionsMap).map(key => optionsMap[key]);
    optionsArr.forEach(async options => await upload(options));
    callback();
  });
};

module.exports = {
  UploadCDN,
};
```

```js
// next.config.js
// ...
  assetPrefix: isProd ? `https://your-cdn-serverice/${yourModule}/${moduleName}/${packageVersion}/prod` : undefined,
  webpack: (config, context) => {
    isProd &&
      config.plugins.push(
        new UploadCDN({
          module: moduleName,
          packageVersion,
          isEnvProduction: isProd,
        }),
      );

    return config;
// ...
```