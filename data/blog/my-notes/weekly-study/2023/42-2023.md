---
title: 2023-第四十二周
date: '2023-10-23'
tags: ['WEEKLY-2023']
draft: false
summary: ''
---

`该周报主要为各个地方内容的汇总整理`

- [技术](#技术)
  - [对抗软件复杂度的战争](#对抗软件复杂度的战争)
  - [Jimmy Breck-McKye](#jimmy-breck-mckye)
  - [The Three Cs: 🤝 Concatenate, 🗜️ Compress, 🗳️ Cache](#the-three-cs-concatenate-️compress-️cache)
  - [Goodbye, Node.js Buffer](#goodbye-nodejs-buffer)
- [工具](#工具)
  - [tinacms](#tinacms)
- [更新](#更新)
  - [CSS prefers-reduced-transparency](#css-prefers-reduced-transparency)
  - [Release: Yarn 4.0 🪄⚗️](#release-yarn-40-️)
  - [Node v21.1.0 (Current)](#node-v2110-current)
  - [Next.js 14](#nextjs-14)
  - [useFormState](#useformstate)
- [其他](#其他)

## 技术

### [对抗软件复杂度的战争](https://mp.weixin.qq.com/s/f82GBadLcQJCiFHcGWzkCA)

本文讨论了对抗软件复杂度的战争。首先，提到了研发效能的概念，指出实际的研发效率往往低于预期。接着，介绍了软件复杂度的指数上升是研发效率降低的核心因素。文章还引用了 Fred Brooks 的“本质复杂度”和“偶然复杂度”的概念，将软件复杂度分为两个方面。然后，强调了复杂度的爆炸，即随着时间的推移和功能的增加，软件复杂度不断上升。最后，指出大规模分布式系统和团队扩张都会引入偶然复杂度。

- 研发效能的降低与软件复杂度的指数上升相关。
- 软件复杂度包括本质复杂度和偶然复杂度。
- 本质复杂度是来自问题域本身的复杂度，无法消除。
- 偶然复杂度是由解决方案带来的，如选择的技术栈和工具。
- 软件复杂度随着时间和功能的增加而不断上升。
- 大规模分布式系统和团队扩张增加了偶然复杂度。

### [Jimmy Breck-McKye](https://www.breck-mckye.com/blog/2023/05/Microfrontends-should-be-your-last-resort/)

这篇文章讨论了微前端（Micro Frontends，MFEs）的概念和问题。作者认为，MFEs 在一些特定情况下是有意义的，但大多数团队应该在采用更复杂的架构之前，先对领域进行良好的重构。MFEs 将复杂的代码分散在多个部分中，导致发布、移动和测试代码变得更加困难。作者建议在采用 MFEs 之前，先从模块化单体应用开始，通过艰苦的重构工作将领域进行拆分。此外，作者还警告 MFEs 可能成为重写旧代码的诱因，而重写项目往往会比预期更加复杂。最后，作者推荐在采用 MFEs 之前，先进行模块化，将代码组织成具有严格架构边界的包，以逐步实现类似于 MFEs 的架构。

- 微前端架构是一种将前端应用拆分为独立部分的方法，但如果不进行良好的解耦，会造成分布式单体架构的问题。
- 在采用微前端架构之前，应先进行领域的重构，以确保代码的解耦和模块化。
- 微前端架构有可能成为一种重新编写代码的方式，但重新编写代码并不简单，且可能导致项目变得更加复杂。

### [The Three Cs: 🤝 Concatenate, 🗜️ Compress, 🗳️ Cache](https://csswizardry.com/2023/10/the-three-c-concatenate-compress-cache/)

这篇文章讨论了在网页中处理文件时需要考虑的一些问题，如文件的拼接、压缩和缓存。作者通过实验发现，在使用 HTTP/2 协议时，将文件拼接成一个大文件比分成多个小文件下载更快。同时，作者还探讨了不同的压缩策略对性能的影响，发现使用更强大的压缩算法可以更好地处理大文件。最后，作者提到了缓存的重要性，建议尽可能地缓存静态资源，并介绍了如何进行缓存控制。

- 在网页中，拼接文件可以提高性能，但在 HTTP/2 中，拼接多个较小的文件反而会导致更高的延迟和更大的文件大小。
- 压缩算法的选择取决于我们的需求和服务器配置，而较大的文件往往可以更好地被压缩。
- 缓存是提高性能的关键，通过使用唯一的指纹和合理的缓存策略，可以实现静态资源的有效缓存。

### [Goodbye, Node.js Buffer](https://sindresorhus.com/blog/goodbye-nodejs-buffer)

这篇文章讨论了在 Node.js 中使用 Buffer 类型处理二进制数据的问题，并提出了使用 Uint8Array 替代 Buffer 的建议。作者计划将自己的包从 Buffer 转换为 Uint8Array，并鼓励其他开发者也这样做。文章介绍了如何进行转换以及可能遇到的问题，并建议使用 linting 来强制使用 Uint8Array。最后，作者呼吁支持 Node.js 在新的 API 中使用 Uint8Array，并提出了 Uint8Array 需要更多实用方法的期望。

- Buffer 类型在 Node.js 中是处理二进制数据的基石，但是现在有了 Uint8Array，它是一种原生的 JavaScript 类型，可以在各种 JavaScript 环境中使用。
- 使用 Buffer 特定方法的代码需要进行 polyfill，阻止了许多有价值的包在浏览器中的兼容性。
- 我计划将所有使用 Buffer 的包迁移到 Uint8Array，并鼓励其他 JavaScript 包的维护者做同样的事情。

## 工具

### [tinacms](https://github.com/tinacms/tinacms)

一个完全开源的无头 CMS，支持 Git 和可视化编辑

## 更新

### [CSS prefers-reduced-transparency](https://developer.chrome.com/en/blog/css-prefers-reduced-transparency/)

从 Chrome 118 版本开始，CSS 媒体查询 5 中的新功能 prefers-reduced-transparency 可用。非不透明的界面可能会给各种类型的视觉缺陷带来困扰。因此，Windows、macOS 和 iOS 都有系统偏好设置，可以减少或删除界面的透明度。这个新的媒体查询功能可以根据用户指定的减少透明度的偏好来适应界面。文章还介绍了减少透明度的一些应用场景，如图片上的半透明标题、透明的模态框和通知、自适应毛玻璃效果等。同时，文章提到了用户偏好的加法和减法观点，以及如何在 Chrome 开发工具中模拟减少透明度的偏好。

- 新的 CSS Media Queries 5 中的 prefers-reduced-transparency 功能可以根据用户的需求调整界面透明度。
- 可以通过 prefers-reduced-transparency 媒体查询来减少或移除图像和 UI 元素的透明度，以适应视力有缺陷的用户。
- 通过媒体查询的使用，设计师和开发人员可以创造性地调整界面透明度，以适应用户的喜好，提供更好的用户体验。

### [Release: Yarn 4.0 🪄⚗️](https://yarnpkg.com/blog/release/4.0)

这段文字宣布了 Yarn 4 的发布，介绍了一些重大变化和改进。其中包括对 Node.js 版本的要求、安装方式的改变、增强模式的引入、约束引擎的改进、插件的变化、用户界面的改进以及性能的提升。同时，还提到了 Yarn 网站的更新和未来的发展计划。总体而言，Yarn 4 的发布旨在降低学习曲线、提升用户体验，并且为未来的发展打下基础。

- Yarn 4.x 发布了，带来了许多重要的改变，包括更高的 Node.js 版本要求、新的安装方式和核心包管理工具 Corepack 的引入。
- Yarn 引入了 Hardened Mode，增加了安全性，但会导致安装速度变慢，可以通过环境变量来开启或关闭。
- Yarn 的界面得到改进，安装过程中提供更多有用的信息，包括已添加的包和它们的总体大小，同时减少了对于可执行操作的警告信息。

### [Node v21.1.0 (Current)](https://nodejs.org/en/blog/release/v21.1.0)

Node.js 21.1.0 版本的重要变化包括自动检测和运行 ES 模块语法，修复了 vm.Script 的 V8 编译缓存支持问题。此外还有其他一些改进和修复，如添加了 flush 选项到 appendFile() 函数、添加了 navigator.userAgent 属性等。

- Node.js 21.1.0 版本引入了自动检测和运行 ESM 语法的功能，通过--experimental-detect-module 标志可以实现自动运行 ES 模块。
- Node.js 的 vm 模块在 v21.1.0 版本中修复了与 V8 编译缓存支持的问题，使得使用 vm.Script 重复编译相同源代码时可以再次使用 V8 编译缓存。
- 其他值得注意的变化包括为 fs 模块的 appendFile() 函数添加了 flush 选项、为 lib 模块添加了 navigator.userAgent 属性、为 stream 模块的 stream.compose() 方法允许传递流类等。

### [Next.js 14](https://nextjs.org/blog/next-14)

Next.js 14 发布了，它包含了许多重要的改进和功能。其中包括 Turbopack 引擎，提供更快的本地服务器启动和代码更新速度，以及稳定的服务器操作功能。此外，还引入了部分预渲染功能，以提供更快的初始静态响应。这个版本还包括了 Next.js 学习课程，教授 App Router、身份验证、数据库等内容。总体来说，Next.js 14 是一个注重性能和开发体验的版本。

- 下一代服务器（稳定）：渐进式增强的突变，与缓存和重新验证集成，通过简单的函数调用或与表单本地化工作。
- 表单和突变：简化数据突变的开发者体验，改善网络连接较慢或使用低功率设备提交表单的用户体验。
- 部分预渲染（预览）：使用快速的初始静态响应和流式动态内容的编译器优化，提供静态和完全动态响应的速度和可靠性。

### [useFormState](https://react.dev/reference/react-dom/hooks/useFormState#my-action-can-no-longer-read-the-submitted-form-data)

useFormState 是 React 的一个 Hook，在 React 的 canary 和 experimental 渠道中可用。它允许您根据表单操作的结果来更新状态。您需要使用支持 React Server Components 的框架才能充分利用 useFormState。使用 useFormState 可以在表单操作时更新组件状态。您将一个现有的表单操作函数和一个初始状态作为参数传递给 useFormState，并且它返回一个新的操作函数，您可以在表单中使用。表单状态是上次提交表单时操作函数的返回值。如果表单尚未提交，它将是您传递的初始状态。使用 useFormState 与服务器操作一起使用时，即使在 hydration 完成之前，也可以显示服务器提交表单的响应。

- useFormState 是 React 的一个 Hook，可以根据表单操作的结果更新状态。
- 使用 useFormState 需要在 React 的 canary 和 experimental channels 中，并且需要使用支持 React Server Components 的框架。
- 调用 useFormState 可以创建组件级别的状态，根据表单操作的调用更新状态，并将最新的状态传递给提供的函数。

## 其他

我经常看到人们不断寻找最好的笔记 App、最好的 Linux 发行版、提高生产力的最佳 AI 软件、最好的游戏引擎……

这样做并不会提高你的效率，你永远找不到最好或最完美的设置。我的建议是，只要一样东西足够好、能完成工作，你就不妨坚持用下去。不要盯着工具，而要盯着你要完成的工作。

-- 《停止沉迷于工具》
